#!/usr/bin/env python3

# srt_to_commentary_js.py
# Description: Converts an SRT subtitle file to a JavaScript module
#              for the live shopping app's commentary/subtitle feature.
# Requirement: pysrt library (install with: pip install pysrt)

import pysrt
import json
import os

def srt_time_to_ms(time_obj):
    """Converts a SubRipTime object to total milliseconds."""
    return (time_obj.hours * 3600 + time_obj.minutes * 60 + time_obj.seconds) * 1000 + time_obj.milliseconds

def srt_time_to_str(time_obj):
    """Formats a SubRipTime object to MM:SS string."""
    total_seconds = time_obj.hours * 3600 + time_obj.minutes * 60 + time_obj.seconds
    minutes = total_seconds // 60
    seconds = total_seconds % 60
    return f"{minutes:02}:{seconds:02}"

def convert_srt_to_js(srt_file_path, output_js_file_path, channel_name="game.commentary"):
    """
    Parses an SRT file and writes the data to a JavaScript module.

    Args:
        srt_file_path (str): Path to the input SRT file.
        output_js_file_path (str): Path for the output JavaScript file.
        channel_name (str): The PubNub channel name for the commentary.
    """
    if not os.path.exists(srt_file_path):
        print(f"Error: SRT file not found at {srt_file_path}")
        print("Please update the 'srt_file_path' variable in the script.")
        return

    try:
        subs = pysrt.open(srt_file_path, encoding='utf-8') # Specify encoding for broader compatibility
    except Exception as e:
        print(f"Error opening or parsing SRT file: {e}")
        return

    new_commentary_entries = []

    for sub in subs:
        # Clean subtitle text: replace newlines with spaces and strip leading/trailing whitespace
        cleaned_text = sub.text.replace('\n', ' ').strip()

        entry = {
            "timeSinceVideoStartedInMs": srt_time_to_ms(sub.start),
            "persistInHistory": False,
            "action": {
                "channel": channel_name,
                "data": {
                    "text": cleaned_text,
                    "timeCode": srt_time_to_str(sub.start)
                }
            }
        }
        new_commentary_entries.append(entry)

    # Ensure the output directory exists
    output_dir = os.path.dirname(output_js_file_path)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            print(f"Created output directory: {output_dir}")
        except OSError as e:
            print(f"Error creating output directory {output_dir}: {e}")
            return

    output_string = f"// Generated by srt_to_commentary_js.py from {os.path.basename(srt_file_path)}\n"
    output_string += "// Target structure: Array of commentary action objects\n\n"
    output_string += "exports.commentary = [\n"
    for i, entry_data in enumerate(new_commentary_entries):
        output_string += "  {\n"
        output_string += f"    timeSinceVideoStartedInMs: {entry_data['timeSinceVideoStartedInMs']},\n"
        output_string += f"    persistInHistory: {str(entry_data['persistInHistory']).lower()},\n"
        output_string += "    action: {\n"
        output_string += f"      channel: '{entry_data['action']['channel']}',\n"
        output_string += "      data: {\n"
        js_text_content = entry_data['action']['data']['text'].replace('\\', '\\\\').replace("'", "\\'").replace('"', '\\"')
        output_string += f"        text: '{js_text_content}'"
        if "timeCode" in entry_data['action']['data']:
            output_string += f",\n        timeCode: '{entry_data['action']['data']['timeCode']}'"
        output_string += "\n      }\n"
        output_string += "    }\n"
        output_string += f"  }}{',' if i < len(new_commentary_entries) - 1 else ''}\n"
    output_string += "];\n"

    try:
        with open(output_js_file_path, 'w', encoding='utf-8') as f:
            f.write(output_string)
        print(f"New commentary JavaScript file created at: {output_js_file_path}")
        print(f"Total entries processed: {len(new_commentary_entries)}")
    except IOError as e:
        print(f"Error writing JavaScript file: {e}")

if __name__ == '__main__':
    print("Starting SRT to JavaScript conversion script.")
    print("Please ensure you have the 'pysrt' library installed (pip install pysrt).")

    # IMPORTANT: USER ACTION REQUIRED
    # Please update the following paths to match your local file structure.

    # Path to your input SRT file:
    # Example: srt_file_path = 'subtitles.srt' (if in the same directory as the script)
    # Example: srt_file_path = '../data/my_video_subtitles.srt'
    srt_file_path = 'subtitles.srt' # <<<< CHANGE THIS IF NEEDED

    # Path for your output JavaScript file:
    # Example: output_js_file_path = 'new_commentary_data.js'
    # Example: output_js_file_path = '../../frontend/src/data/generated_subtitles.js'
    output_js_file_path = 'generated_commentary.js' # <<<< CHANGE THIS IF NEEDED

    # Optional: Change the channel name if desired
    # channel_name_for_output = "game.commentary" 
    channel_name_for_output = "game.commentary" # Defaulting to a new channel name for clarity

    print(f"Input SRT file: {os.path.abspath(srt_file_path)}")
    print(f"Output JS file: {os.path.abspath(output_js_file_path)}")
    print(f"Using channel name: {channel_name_for_output}")

    # Make sure srt_file_path is relative to the script's location if not absolute
    # Assuming this script (srt_to_commentary_js.py) is in the 'cursor_helper' folder,
    # and 'subtitles.srt' is also in 'cursor_helper'.
    script_dir = os.path.dirname(__file__) if '__file__' in locals() else os.getcwd()
    
    # Adjust srt_file_path to be relative to script_dir if it's not an absolute path
    if not os.path.isabs(srt_file_path):
        # srt_file_path_abs = os.path.join(script_dir, srt_file_path)
        # Ensure srt_file_path specifically points within cursor_helper if relative
        # Assuming subtitles.srt is in the same directory as the script (cursor_helper)
        srt_file_path_abs = os.path.join(script_dir, os.path.basename(srt_file_path))
    else:
        srt_file_path_abs = srt_file_path

    # Adjust output_js_file_path to be relative to script_dir if it's not an absolute path 
    # and no other directory is specified
    if not os.path.isabs(output_js_file_path) and not os.path.dirname(output_js_file_path):
        # output_js_file_path_abs = os.path.join(script_dir, output_js_file_path)
        # Ensure output_js_file_path specifically points within cursor_helper if relative and no dir given
        output_js_file_path_abs = os.path.join(script_dir, os.path.basename(output_js_file_path))
    elif not os.path.isabs(output_js_file_path):
        # if it has a directory part, join it with script_dir
        output_js_file_path_abs = os.path.join(script_dir, output_js_file_path)

    print(f"Attempting to read from: {srt_file_path_abs}")
    print(f"Attempting to write to: {output_js_file_path_abs}")

    convert_srt_to_js(srt_file_path_abs, output_js_file_path_abs, channel_name_for_output)

    print("Script finished.") 